<h1 id='query-api-beta'>Query API (beta)</h1>
<p>While the Data API allows query behaviour over a single data set, the Query API allows broader control over the Namara data catalog. This is a new API that will eventually replace the Data API. We wrote <strong>NiQL</strong> (<strong>N</strong>amara.<strong>i</strong>o <strong>Q</strong>uery <strong>L</strong>anguage) to view, aggregate, and join data sets. It&#39;s very similar to SQL, so it&#39;s easy to manipulate.</p>

<aside class="notice">This feature is currently in beta - to request early access, <a href="https://namara.io/contact/" rel="noopener noreferrer" target="_blank">contact us</a>.</aside>
<h2 id='get-meta'><div class="colour-pill"><span class="get">GET</span> Meta</div></h2>
<blockquote>
<p>https://api.namara.io/v0/query/meta</p>
</blockquote>
<pre class="highlight plaintext"><code>{
  "query_limit_maximum": 250,
  "formats": ["geojson", "csv", "json"],
  "default_format": "json"
}
</code></pre>
<p>This endpoint provides the meta information for querying this Namara instance. It includes the limit per query, the supported formats, and the default format if none is specified. This information may differ, depending on which deployment of Namara you&#39;re using. </p>
<h2 id='post-query'><div class="colour-pill"><span class="post">POST</span> Query</div></h2>
<blockquote>
<p>https://api.namara.io/v0/query.:format</p>
</blockquote>

<p>A call here dispatches a query and returns the result.</p>
<h3 id='request'>Request</h3>
<table><thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>format</td>
<td><code>string</code></td>
<td>Query response format: <code>CSV</code>, <code>JSON</code>, or <code>GeoJSON</code> (default is <code>JSON</code>)</td>
</tr>
<tr>
<td>project_id</td>
<td><code>string</code></td>
<td>Project ID to use for subscription lookup. If not provided, it is inferred from API Key</td>
</tr>
<tr>
<td>organization_id</td>
<td><code>string</code></td>
<td>Organization ID to use for subscription lookup. If not provided, it is inferred from API Key</td>
</tr>
<tr>
<td>query (required)</td>
<td><code>string</code></td>
<td>NiQL query string</td>
</tr>
<tr>
<td>geojson_feature_key (may be required)</td>
<td><code>string</code></td>
<td>Property name to use as geometry when rendering <code>GeoJSON</code></td>
</tr>
</tbody></table>

<p>The <code>geojson_feature_key</code> is required if the requested format is <code>GeoJSON</code> - otherwise, it is not needed.</p>
<h3 id='responses'>Responses</h3><h3 id='200-ok'>200: OK</h3>
<p>Query executed successfully.</p>

<p><button class="see-json">JSON</button> 
<button class="see-csv">CSV</button> 
<button class="see-geojson">GeoJSON</button> </p>

<div class="center-column response-json"></div>
<pre class="highlight plaintext"><code>  {
    "results":[
      {
        "c0":"foo",
        "c1":22,
        "c2":"xx",
        "c3":"POINT (-79.4 43.7)"
      },
      ...
    ]
  }
</code></pre>
<div class="center-column response-csv"></div>
<pre class="highlight plaintext"><code>  c0,c1,c2,c3
  foo,22,xx,POINT (-79.4 43.7)
  bar,66,yy,POINT (-78.4 42.7)
  baz,11,xx,POINT (-70.4 35.7)
</code></pre>
<div class="center-column response-geojson"></div>
<pre class="highlight plaintext"><code>  {
    "type":"FeatureCollection",
    "features":[
      {
        "type":"Feature",
        "geometry":{
          "type":"Point",
          "coordinates": [ -79.4, 43.7 ]
        },
        "properties":{
          "c0":"foo",
          "c1":22,
          "c2":"xx"
        }
      },
      ...
    ]
  }
</code></pre><h3 id='422-unprocessable-entity'>422: Unprocessable Entity</h3>
<p>Something went wrong with the request.</p>

<div class="center-column"></div>
<pre class="highlight plaintext"><code>{ "error": &lt;Error message&gt; }
</code></pre><h2 id='query-specification'>Query Specification</h2>
<p><strong>NiQL</strong> is modelled after standard SQL, but only supports read-only <code>SELECT</code> statements. A traditional query must at minimum have a <code>SELECT</code> and <code>FROM</code> clause in order to execute. While the <code>SELECT</code> clause can be anything, the <code>FROM</code> clause must specify a data set and version to query. </p>
<pre class="highlight shell tab-shell"><code>curl -i <span class="se">\</span>
-H <span class="s2">"Content-Type: application/json"</span> <span class="se">\ </span>
-H <span class="s2">"X-API-Key: {YOUR_API_KEY}"</span> <span class="se">\ </span>
-X POST <span class="se">\ </span>
-d <span class="s1">'{"query": "SELECT * FROM 2a6412c0-b3c9-420e-9487-abd21b664ac1/en-1 AS BramptonHomes"}'</span> <span class="se">\ </span>
https://api.namara.io/v0/query.json
</code></pre>
<p>For example, if we were looking to query a data set with an id of <code>2a6412c0-b3c9-420e-9487-abd21b664ac1</code> and the version <code>en-1</code>, our minimum query would look like the example in the code column.</p>

<p>The parser will verify the table name and handle queries that reference it, but using aliases and quotes whenever possible is recommended.</p>

<p>Below is a summary of supported features:</p>
<h2 id='select-features'>SELECT Features</h2><h3 id='count'>COUNT</h3>
<div class="center-column"></div>
<pre class="highlight sql tab-sql"><code>  <span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
  <span class="k">FROM</span> <span class="nv">"data-set-id/en-0"</span>

  <span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="n">column1</span><span class="p">)</span>
  <span class="k">FROM</span> <span class="nv">"data-set-id/en-0"</span>
</code></pre><h3 id='distinct'>DISTINCT</h3>
<div class="center-column"></div>
<pre class="highlight sql tab-sql"><code>  <span class="k">SELECT</span> <span class="k">DISTINCT</span> <span class="n">column1</span><span class="p">,</span> <span class="n">column2</span>
  <span class="k">FROM</span> <span class="nv">"data-set-id/en-0"</span>
</code></pre><h3 id='count-distinct'>COUNT DISTINCT</h3>
<div class="center-column"></div>
<pre class="highlight sql tab-sql"><code>  <span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="k">DISTINCT</span> <span class="n">column1</span><span class="p">)</span>
  <span class="k">FROM</span> <span class="nv">"data-set-id/en-0"</span>
</code></pre><h3 id='min-and-max'>MIN AND MAX</h3>
<div class="center-column"></div>
<pre class="highlight sql tab-sql"><code>  <span class="k">SELECT</span> <span class="k">MIN</span><span class="p">(</span><span class="n">column1</span><span class="p">)</span> <span class="k">AS</span> <span class="n">minColumn1</span><span class="p">,</span> <span class="k">MAX</span><span class="p">(</span><span class="n">column2</span><span class="p">)</span> <span class="k">AS</span> <span class="n">maxColumn2</span>
  <span class="k">FROM</span> <span class="nv">"data-set-id/en-0"</span>
</code></pre><h3 id='avg-and-sum'>AVG AND SUM</h3>
<div class="center-column"></div>
<pre class="highlight sql tab-sql"><code>  <span class="k">SELECT</span> <span class="k">AVG</span><span class="p">(</span><span class="n">column1</span><span class="p">)</span> <span class="k">AS</span> <span class="n">avgColumn1</span><span class="p">,</span> <span class="k">SUM</span><span class="p">(</span><span class="n">column1</span><span class="p">)</span> <span class="k">AS</span> <span class="n">sumColumn1</span>
  <span class="k">FROM</span> <span class="nv">"data-set-id/en-0"</span>
</code></pre><h2 id='from-features'>FROM Features</h2><h3 id='joins'>JOINS</h3>
<div class="center-column"></div>
<pre class="highlight sql tab-sql"><code>  <span class="k">SELECT</span> <span class="n">DataSet1</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">DataSet1</span><span class="p">.</span><span class="n">city</span><span class="p">,</span> <span class="n">DataSet2</span><span class="p">.</span><span class="n">country</span>
  <span class="k">FROM</span> <span class="nv">"data-set-id/en-0"</span> <span class="k">AS</span> <span class="n">DataSet1</span> <span class="k">INNER</span> <span class="k">JOIN</span> <span class="nv">"data-set-id2/en-1"</span> <span class="k">AS</span> <span class="n">DataSet2</span>
  <span class="k">ON</span> <span class="n">DataSet1</span><span class="p">.</span><span class="n">foreign_id</span> <span class="o">=</span> <span class="n">DataSet2</span><span class="p">.</span><span class="n">external_id</span>
</code></pre>
<p><br />
Supports:</p>

<ul>
<li>INNER JOIN</li>
<li>RIGHT [OUTER] JOIN</li>
<li>LEFT [OUTER] JOIN</li>
<li>Implicit joins</li>
</ul>
<h3 id='unions'>UNIONS</h3>
<div class="center-column"></div>
<pre class="highlight sql tab-sql"><code>  <span class="k">SELECT</span> <span class="n">id</span>
  <span class="k">FROM</span> <span class="nv">"data-set-id/en-0"</span>
  <span class="k">UNION</span>
  <span class="k">SELECT</span> <span class="n">objectid</span>
  <span class="k">FROM</span> <span class="nv">"data-set-id2/en-1"</span>
</code></pre><h2 id='where-features'>WHERE Features</h2><h3 id='conditions'>Conditions</h3>
<div class="center-column"></div>
<pre class="highlight sql tab-sql"><code>  <span class="k">SELECT</span> <span class="n">id</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">city</span><span class="p">,</span> <span class="n">province</span><span class="p">,</span> <span class="n">country</span>
  <span class="k">FROM</span> <span class="nv">"data-set-id/en-0"</span>
  <span class="k">WHERE</span> <span class="p">(</span><span class="n">country</span> <span class="o">=</span> <span class="s1">'Canada'</span> <span class="k">AND</span> <span class="n">province</span> <span class="o">=</span> <span class="s1">'Manitoba'</span> <span class="k">AND</span> <span class="k">NOT</span> <span class="n">city</span> <span class="o">=</span> <span class="s1">'Winnipeg'</span><span class="p">)</span> <span class="k">OR</span> <span class="n">country</span> <span class="o">=</span><span class="s1">'Mexico'</span>
</code></pre><h3 id='like'>LIKE</h3>
<div class="center-column"></div>
<pre class="highlight sql tab-sql"><code>  <span class="k">SELECT</span> <span class="o">*</span>
  <span class="k">FROM</span> <span class="nv">"data-set-id/en-0"</span>
  <span class="k">WHERE</span> <span class="n">country</span> <span class="k">LIKE</span> <span class="s1">'C_%'</span>
</code></pre><h3 id='order-by'>ORDER BY</h3>
<div class="center-column"></div>
<pre class="highlight sql tab-sql"><code>  <span class="k">SELECT</span> <span class="o">*</span>
  <span class="k">FROM</span> <span class="nv">"data-set-id/en-0"</span>
  <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">country</span><span class="p">,</span> <span class="n">province</span><span class="p">,</span> <span class="p">...</span> <span class="p">[</span><span class="k">ASC</span><span class="o">|</span><span class="k">DESC</span><span class="p">]</span>
</code></pre><h3 id='in'>IN</h3>
<div class="center-column"></div>
<pre class="highlight sql tab-sql"><code>  <span class="k">SELECT</span> <span class="o">*</span>
  <span class="k">FROM</span> <span class="nv">"data-set-id/en-0"</span>
  <span class="k">WHERE</span> <span class="n">country</span> <span class="k">IN</span> <span class="p">(</span><span class="s1">'Mexico'</span><span class="p">,</span> <span class="s1">'Canada'</span><span class="p">,</span> <span class="p">...)</span>
</code></pre><h3 id='between'>BETWEEN</h3>
<div class="center-column"></div>
<pre class="highlight sql tab-sql"><code>  <span class="k">SELECT</span> <span class="o">*</span>
  <span class="k">FROM</span> <span class="nv">"data-set-id/en-0"</span>
  <span class="k">WHERE</span> <span class="n">liquidation_date</span> <span class="k">BETWEEN</span> <span class="mi">2016</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">01</span> <span class="k">AND</span> <span class="mi">2018</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">01</span>
</code></pre><h2 id='group-by-and-having'>GROUP BY and HAVING</h2>
<div class="center-column"></div>
<pre class="highlight sql tab-sql"><code>  <span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="n">customer_id</span><span class="p">),</span> <span class="n">country</span>
  <span class="k">FROM</span> <span class="nv">"data-set-id/en-0"</span>
  <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">country</span>
  <span class="k">HAVING</span> <span class="k">COUNT</span><span class="p">(</span><span class="n">customer_id</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">100</span> 
</code></pre><h3 id='subselects'>Subselects</h3>
<div class="center-column"></div>
<pre class="highlight sql tab-sql"><code>  <span class="k">SELECT</span> <span class="o">*</span>
  <span class="k">FROM</span> <span class="nv">"data-set-id/en-0"</span>
  <span class="k">WHERE</span> <span class="n">total_count</span> <span class="o">=</span> <span class="p">[</span><span class="k">ANY</span><span class="o">|</span><span class="k">ALL</span><span class="p">]</span> <span class="p">(</span><span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="n">customer_id</span><span class="p">)</span> <span class="k">FROM</span> <span class="nv">"data-set-id2/en-1"</span><span class="p">)</span>
</code></pre>
<div class="center-column"></div>
<pre class="highlight sql tab-sql"><code>  <span class="k">SELECT</span> <span class="o">*</span>
  <span class="k">FROM</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">customer_id</span><span class="p">,</span> <span class="n">parent_account_id</span><span class="p">,</span> <span class="n">purchase_total</span> <span class="k">FROM</span> <span class="nv">"data-set-id2/en-1"</span><span class="p">)</span>
  <span class="k">AS</span> <span class="n">subSelect</span>
  <span class="k">WHERE</span> <span class="n">purchase_total</span> <span class="o">&gt;</span> <span class="mi">1500</span>
</code></pre><h2 id='geospatial-features'>Geospatial Features</h2>
<p>Geometry properties for data sets are stored as <code>GeoJSON</code>, and will be rendered as that unless instructed otherwise. You can do this using the transformation functions <code>ST_GeomFromText</code> to create geometry objects, which can then be manipulated and transformed. Use <code>ST_AsGeoJSON</code> or <code>ST_AsText</code> in order to turn the final result back to text from binary.  </p>

<p>Here&#39;s an example in which <code>geometry_property</code> is a property from the data set of type geometry (this information can be obtained in the API Info tab when viewing a data set):</p>

<div class="center-column"></div>
<pre class="highlight sql tab-sql"><code>  <span class="k">SELECT</span> <span class="n">ST_AsGeoJSON</span><span class="p">(</span><span class="n">ST_GeomFromText</span><span class="p">(</span><span class="n">geometry_property</span><span class="p">))</span>
  <span class="k">FROM</span> <span class="nv">"data-set-id/en-0"</span>
</code></pre><h3 id='supported-functions'>Supported Functions</h3>
<blockquote>
<p><code>ST_AsGeoJSON</code><br/>
<code>ST_AsJson</code><br/>
<code>ST_AsText</code><br/>
<code>ST_Buffer</code><br/>
<code>ST_Contains</code><br/>
<code>ST_Crosses</code><br/>
<code>ST_Difference</code><br/>
<code>ST_Disjoint</code><br/>
<code>ST_Distance</code><br/>
<code>ST_DWithin</code><br/>
<code>ST_Envelope</code><br/>
<code>ST_Equals</code><br/>
<code>ST_GeomFromText</code><br/>
<code>ST_GeomFromTextSrid</code><br/>
<code>ST_Intersects</code><br/>
<code>ST_Overlaps</code><br/>
<code>ST_PointFunc</code><br/>
<code>ST_Relate</code><br/>
<code>ST_Touches</code><br/>
<code>ST_Transform</code><br/>
<code>ST_Union</code><br/>
<code>ST_UnionAggregate</code><br/>
<code>ST_Within</code><br/>
<code>ST_XFunc</code><br/>
<code>ST_XMax</code><br/>
<code>ST_XMin</code><br/>
<code>ST_YFunc</code><br/>
<code>ST_YMax</code><br/>
<code>ST_YMin</code><br/></p>
</blockquote>

<p>We are very interested in expanding the geospatial capabilities of <strong>NiQL</strong>. If there is additional functionality you need, or there are any issues with the the implementations, please do not hesitate to <a href="https://namara.io/contact" target="_blank" rel="noreferrer noopener">reach out to us</a>.</p>

<aside class="notice">Please refer to the <a href="https://postgis.net/docs/reference.html" target="_blank" rel="noreferrer noopener">PostGIS documentation</a> for the functional specifics</aside>
<h2 id='pagination-with-niql'>Pagination with <strong>NiQL</strong></h2>
<p>Like the Data API, a maximum number of rows will be returned on each query. If the query string does not contain <code>LIMIT X OFFSET Y</code>, the parser will append the maximum number of allowable rows in order to enforce the limit.</p>

<p>For results larger than the allowed amount, manual pagination in subsequent requests will have to be used.</p>

<p>The default limit is <code>250</code> rows, but this may vary depending on which deployment of Namara you are interacting with. Refer to the <a href="#get-meta">Meta endpoint</a> for instructions on how to obtain this information.</p>
